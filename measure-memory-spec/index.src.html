<pre class="metadata">
Title: Measure Memory API
Status: CG-DRAFT
Group: WICG
Repository: WICG/performance-measure-memory
Shortname: performance-measure-memory
Markup Shorthands: markdown yes
Markup Shorthands: css no
Level: None
URL: https://wicg.github.io/performance-measure-memory/
Abstract:
  This specification defines an API that allows web applications to measure their memory usage.
Indent: 2
Default Biblio Status: current
Boilerplate: omit conformance, omit feedback-header
Complain About: accidental-2119 yes, missing-example-ids yes
!Participate: <a href="https://github.com/WICG/performance-measure-memory">GitHub WICG/performance-measure-memory</a> (<a href="https://github.com/WICG/performance-measure-memory/issues/new">new issue</a>, <a href="https://github.com/WICG/performance-measure-memory/issues?state=open">open issues</a>)
</pre>


<pre class="anchors">
urlPrefix: https://tc39.es/ecma262/; spec: ECMAScript
  text: SharedArrayBuffer; type: interface; url: sec-sharedarraybuffer-objects
  text: JavaScript realm; type: interface; url: sec-code-realms
  text: JavaScript realms; type: interface; url: sec-code-realms
urlPrefix: https://www.w3.org/TR/hr-time-2; spec: HR-TIME-2
  type: interface
    text: Performance; url: #sec-performance
  type: grammar
    text: sh-token; url: #section-3.9
  type: abstract-op
    text: serialize Structured Header; url: #section-4.1
    text: Structured Header parsing algorithm; url: #section-4.2.7
urlPrefix: https://html.spec.whatwg.org/
  type: dfn
    text: top-level browsing context group; url: multipage/browsers.html#tlbc-group
  type: abstract-op
    text: set up a worker environment settings object; url: multipage/set-up-a-worker-environment-settings-object
    text: set up a window environment settings object; url: multipage/set-up-a-window-environment-settings-object
    text: create and initialize a Document object; url: multipage/initialise-the-document-object
    text: create a new browsing context; url: multipage/browsers.html#creating-a-new-browsing-context
</pre>

<pre class="link-defaults">
spec:fetch; type:dfn; for:/; text:request
spec:fetch; type:dfn; text: cors check
spec:fetch; type:dfn; for:/; text:network error
spec:url; type:dfn; for:/; text:url
spec:html; type:dfn; for:/; text:browsing context
spec:html; type:dfn; text:environment
spec:html; type:dfn; text: browsing context group
spec:fetch; type:dfn; for:/; text:response
spec:fetch; type:dfn; for:/; text:cross-origin resource policy check
spec:html; type:dfn; for:/; text:global object
spec:html; type:dfn; for:/; text:container document
spec:html; type:dfn; for:/; text:parent browsing context
</pre>


<style>
/* domintro from https://resources.whatwg.org/standard.css */
.domintro {
  position: relative;
  color: green;
  background: #DDFFDD;
  margin: 2.5em 0 2em 0;
  padding: 1.5em 1em 0.5em 2em;
}

.domintro dt, .domintro dt * {
  color: black;
  font-size: inherit;
}
.domintro dd {
  margin: 0.5em 0 1em 2em; padding: 0;
}
.domintro dd p {
  margin: 0.5em 0;
}
.domintro::before {
  content: 'For web developers (non-normative)';
  background: green;
  color: white;
  padding: 0.15em 0.25em;
  font-style: normal;
  position: absolute;
  top: -0.8em;
  left: -0.8em;
}
</style>


Introduction {#intro}
=====================


Examples {#examples}
--------------------

<div class="example" id="example">

A `performance.measureMemory()` call returns a {{Promise}} and starts
asynchronous measurement of memory allocated by the page.

```javascript
async function run() {
  const result = await performance.measureMemory();
  console.log(result);
}
run();
```

For a simple page without iframes and workers the result may look as follows:
```javascript
{
  bytes: 1000000,
  breakdown: [
    {
      bytes: 1000000,
      attribution: [
        {
          url: "https://example.com",
          scope: "window",
        },
      ],
      userAgentSpecificTypes: ["JS", "DOM"],
    },
  ],
}
```
Here all memory is attributed to the main page.

Other possible valid results:
```javascript
{
  bytes: 1000000,
  breakdown: [],
}
```
Here the implementation provides only the total memory usage.

```javascript
{
  bytes: 1000000,
  breakdown: [
    {
      bytes: 1000000,
      attribution: [
        {
          url: "https://example.com",
          scope: "window",
        },
      ],
      userAgentSpecificTypes: [],
    },
  ],
}
```
Here the implementation does not break memory down by memory types.

</div>

<div class="example" id="example">

For a page that embeds a same-origin iframe the result may attribute some memory
to that iframe and provide diagnostic information for identifying the iframe:

 ```html
  <html>
    <body>
      <iframe id="example-id" src="redirect.html?target=iframe.html"></iframe>
    </body>
  </html>
```

```javascript
{
  bytes: 1500000,
  breakdown: [
    {
      bytes: 1000000,
      attribution: [
        {
          url: "https://example.com",
          scope: "window",
        },
      ],
      userAgentSpecificTypes: ["JS", "DOM"],
    },
    {
      bytes: 500000,
      attribution: [
        {
          url: 'https://example.com/iframe.html'
          container: {
            id: "example-id",
            src: 'redirect.html?target=iframe.html',
            tagName: 'iframe',
          },
          scope: 'window',
        }
      ],
      userAgentSpecificTypes: ['JS', 'DOM'],
    },
  ],
}
```
Note how the `url` and `container.src` fields differ for the iframe.
The former reflects the current `location.href` of the iframe whereas the
latter is the value of the `src` attribute of the iframe element.

It is not always possible to separate iframe memory from page memory in a
meaningful way.
An implementation is allowed to lump together some or all of iframe and page memory:
```javascript
{
  bytes: 1500000,
  breakdown: [
    {
      bytes: 1500000,
      attribution: [
        {
          url: "https://example.com",
          scope: "window",
        },
        {
          url: "https://example.com/iframe.html",
          container: {
            id: "example-id",
            src: "redirect.html?target=iframe.html",
            tagName: "iframe",
          },
          scope: "window",
        },
      ],
      userAgentSpecificTypes: ["JS", "DOM"],
    },
  ],
};
```
</div>

<div class="example" id="example">
For a page that spawns a web worker the result includes the URL of the worker.
```javascript
{
  bytes: 1800000,
  breakdown: [
    {
      bytes: 1000000,
      attribution: [
        {
          url: "https://example.com",
          scope: "window",
        },
      ],
      userAgentSpecificTypes: ["JS", "DOM"],
    },
    {
      bytes: 800000,
      attribution: [
        {
          url: "https://example.com/worker.js",
          scope: "dedicated-worker",
        },
      ],
      userAgentSpecificTypes: ["JS"],
    },
  ],
};

```
An implementation may lump together worker and page memory. If a worker is
spawned by an iframe, then worker's attribution entry has a `container` field
corresponding to the iframe element.

Memory of shared and service workers is not included in the result.
</div>


<div class="example" id="example">
To get the memory usage of a shared/service worker, the `performance.measureMemory()`
function needs to be invoked in the context of that worker.
```javascript
{
  bytes: 1000000,
  breakdown: [
    {
      bytes: 1000000,
      attribution: [
        {
          url: "https://example.com/service-worker.js",
          scope: "service-worker",
        },
      ],
      userAgentSpecificTypes: ["JS"],
    },
  ],
}
```
</div>

<div class="example" id="example">
If a page embeds a cross-origin iframe, then the URL of that iframe is not
revealed to avoid information leaks. Only the container element
(which is already known to the page) appears in the result.
Additionally, if the cross-origin iframe embeds other cross-origin iframes
and/or spawns workers, then all their memory is aggregated and attributed to
the top-most cross-origin iframe.

Consider a page with the following structure:

```javascript
example.com (1000000 bytes)
  |
  *--foo.com/iframe1 (500000 bytes)
       |
       *--foo.com/iframe2 (200000 bytes)
       |
       *--bar.com/iframe2 (300000 bytes)
       |
       *--foo.com/worker.js (400000 bytes)
```
A cross-origin iframe embeds to other iframes and spawns a worker.
All memory of these resources is attributed to the first iframe.

 ```html
  <html>
    <body>
      <iframe id="example-id" src="https://foo.com/iframe1"></iframe>
    </body>
  </html>
```

```javascript
{
  bytes: 2400000,
  breakdown: [
    {
      bytes: 1000000,
      attribution: [
        {
          url: "https://example.com",
          scope: "window",
        },
      ],
      userAgentSpecificTypes: ["JS", "DOM"],
    },
    {
      bytes: 1400000,
      attribution: [
        {
          url: "cross-origin-url",
          container: {
            id: "example-id",
            src: "https://foo.com/iframe1",
            tagName: "iframe",
          },
          scope: "cross-origin-aggregated",
        },
      ],
      userAgentSpecificTypes: ["JS", "DOM"],
    },
  ],
}
```
Note that the `url` and `scope` fields of the cross-origin iframe entry have
special values indicating that information is not available.
</div>

<div class="example" id="example">
If a cross-origin iframe embeds an iframe of the same origin as the main page,
then the same-origin iframe is revealed in the result.
Note that there is no information leak because the main page can find and read
`location.href` of the same-origin iframe.

```javascript
example.com (1000000 bytes)
  |
  *--foo.com/iframe1 (500000 bytes)
       |
       *--example.com/iframe2 (200000 bytes)
```
 ```html
  <html>
    <body>
      <iframe id="example-id" src="https://foo.com/iframe1"></iframe>
    </body>
  </html>
```

```javascript
{
  bytes: 1700000,
  breakdown: [
    {
      bytes: 1000000,
      attribution: [
        {
          url: "https://example.com",
          scope: "window",
        },
      ],
      userAgentSpecificTypes: ["JS", "DOM"],
    },
    {
      bytes: 500000,
      attribution: [
        {
          url: "cross-origin-url",
          container: {
            id: "example-id",
            src: "https://foo.com/iframe1",
            tagName: "iframe",
          },
          scope: "cross-origin-aggregated",
        },
      ],
      userAgentSpecificTypes: ["JS", "DOM"],
    },
    {
      bytes: 200000,
      attribution: [
        {
          url: "https://example.com/iframe2",
          container: {
            id: "example-id",
            src: "https://foo.com/iframe1",
            tagName: "iframe",
          },
          scope: "window",
        },
      ],
      userAgentSpecificTypes: ["JS", "DOM"],
    },
  ],
}
```
</div>

Data model {#data-model}
============================

Memory measurement result
-------------------------

The `performance.measureMemory()` function returns a {{Promise}} that resolves to an instance of `MemoryMeasurement` dictionary:

<pre class="idl">
dictionary MemoryMeasurement {
  required unsigned long long bytes;
  required sequence&lt;MemoryBreakdownEntry&gt; breakdown;
};
</pre>
<dl class="domintro">
:  <code>self . {{MemoryMeasurement/bytes}}</code>
:: A number that represents the total memory usage.

:  <code>self . {{MemoryMeasurement/breakdown}}</code>
:: A list that partitions the total {{MemoryMeasurement/bytes}} and provides attribution and type information.
</dl>

<pre class="idl">
dictionary MemoryBreakdownEntry {
  required unsigned long long bytes;
  required sequence&lt;MemoryAttribution&gt; attribution;
  required sequence&lt;DOMString&gt; userAgentSpecificTypes;
};
</pre>
<dl class="domintro">
:  <code>self . {{MemoryBreakdownEntry/bytes}}</code>
:: The size of the memory that this entry describes.

:  <code>self . {{MemoryBreakdownEntry/attribution}}</code>
:: A set of [$JavaScript realms$] specified by their URLs and/or container elements that use the memory.

:  <code>self . {{MemoryBreakdownEntry/userAgentSpecificTypes}}</code>
:: A set of implementation defined memory types associated with the memory.
</dl>

<pre class="idl">
dictionary MemoryAttribution {
  DOMString url;
  MemoryAttributionContainer container;
  required DOMString scope;
};
</pre>
<dl class="domintro">
:  <code>self . {{MemoryAttribution/url}}</code>
:: If this attribution corresponds to a same-origin [$JavaScript realm$], then this field contains realm's URL.
   Otherwise, the attribution is for one or more cross-origin [$JavaScript realms$] and this field contains
   a sentinel value: `"cross-origi-url"`.

:  <code>self . {{MemoryAttribution/container}}</code>
:: Describes the DOM element that (maybe indirectly) contains the [$JavaScript realms$].
   It may be empty if the attribution is for the same-origin top-level realm.
   Note that cross-origin realms cannot be top-level due to [=cross-origin isolation=].

:  <code>self . {{MemoryAttribution/scope}}</code>
:: Describes the type of the same-origin [$JavaScript realm$]:
   <code>"window", "dedicated-worker", "shared-worker", "service-worker"</code>
   or contains <code>"cross-origin-aggregated"</code> for the cross-origin case.
</dl>

<pre class="idl">
dictionary MemoryAttributionContainer {
  DOMString id;
  DOMString src;
  DOMString data;
  DOMString name;
  required DOMString tagName;
};
</pre>
<dl class="domintro">
:  <code>self . {{MemoryAttributionContainer/id}}</code>
:: The id attribute of the container element.

:  <code>self . {{MemoryAttributionContainer/src}}</code>
:: The src attribute of the container element.

:  <code>self . {{MemoryAttributionContainer/data}}</code>
:: The data attribute of the container element.

:  <code>self . {{MemoryAttributionContainer/name}}</code>
:: The name attribute of the container element.

:  <code>self . {{MemoryAttributionContainer/tagName}}</code>
:: The tag of the container element.
</dl>

Intermediate memory measurement
-------------------------------

This specification assumes the existences of an implementation-defined algorithm that can measure
the memory of objects allocated by a set of [$JavaScript agent clusters$].
The result of such algorithm is an <dfn>intermediate memory measurement</dfn>,
which is a [=set=] of [=intermediate memory breakdown entries=].

An <dfn>intermediate memory breakdown entry</dfn> is a [=struct=] containing the following [=struct/items=]:
:  <dfn for="intermediate memory breakdown entry">bytes</dfn>
:: The size of the memory that this [=intermediate memory breakdown=] describes.

:  <dfn for="intermediate memory breakdown entry">realms</dfn>
:: A [=set=] of [$JavaScript realms$] to which the memory is attributed to.

:  <dfn for="intermediate memory breakdown entry">user agent specific types</dfn>
:: A [=set=] of [=/strings=] specifying implementation defined memory types associated with the memory.

Algorithms defined in this specification show how to convert an [=intermediate memory measurement=]
to an instance of {{MemoryMeasurement}}.

Memory attribution token
------------------------

The link between an embedded [$JavaScript realm$] and its container element is ephemeral and is not guaranteed to always exist.
For example, navigation to another document in the container element or removal of the container element from the DOM tree severs the link.

A <dfn>memory attribution token</dfn> is a [=struct=] containing the following [=struct/items=]:
:  <dfn for="memory attribution token">container</dfn>
:: An instance of {{MemoryAttributionContainer}}.

: <dfn for="memory attribution token">cross-origin aggregated flag</dfn>
:: A [=boolean=] flag indicating whether the token was created for aggregating memory usage of
   cross-origin JavaSript realms.

It is stored in a new field of realm's [=settings object=] at realm creation time and is always available for memory reporting.


Processing model {#processing-model}
====================================

Top-level algorithms
--------------------
<div algorithm>
  <dfn>performance.measureMemory</dfn> must run the following steps:
  1. Let |realm| be the [=current settings object=]'s [=environment settings object/Realm=].
  1. [=Assert=]: |realm|'s [=agent=]'s [=agent cluster=]'s [=cross-origin-isolated=] is true.
  1. Let |global object| be the [=current global object=].
  1. Let |promise| be a new {{Promise}}.
  1. If [=memory measurement allowed predicate=] given |global object| and |settings object| is false, then:
      1. {{Promise/Reject}} |promise| with a "Security Error" {{DOMException}}.
  1. Let |agent clusters| be the result of [=getting all agent clusters=] given |realm|.
  1. Start asynchronous implementation-defined memory measurement given |agent clusters| and |promise|.
  1. Return |promise|
</div>

<div algorithm>
  To evaluate <dfn>memory measurement allowed predicate</dfn>
  given a {{WindowOrWorkerGlobalScope}} |global object| and [=environment settings object=] |settings object|:
  1. If |global object| is a {{SharedWorkerGlobalScope}}, then return true.
  1. If |global object| is a {{ServiceWorkerGlobalScope}}, then return true.
  1. If |global object| is a {{Window}} and |settings object|'s [=environment settings object/origin=]
     is the same as |settings object|'s [=environment settings object/topLevelOrigin=], then return true.
  1. Return false.
</div>

<div algorithm>
  To <dfn lt="getting all agent clusters|get all agent clusters">get all agent clusters</dfn>
  given an {{JavaScript realm}}  |realm|:
  1. If |realm|'s [=global object=] is a {{Window}}, then:
      1. Let |browsing context| be |realm|'s [=settings object=]'s [=responsible document=]'s [=document/browsing context=].
      1. Let |agent clusters| be the result of [=map/getting the values=] of |browsing context|'s
         [=browsing context group=]'s [=agent cluster map=].
      1. Return |agent clusters|.
  1. Return a singleton [=set=] of |realm|'s [=agent=]'s [=agent cluster=].
</div>

<div algorithm>
  To perform <dfn>implementation-defined memory measurement</dfn> given a [=set=] of [=agent clusters=] |agent clusters| and
  a {{Promise}} |promise| run these steps asynchronously:
  1. Let |intermediate memory measurement| be implementation-defined memory measurement of |agent clusters|.
  1. Let |memory measurement| be the result of [=creating a new memory measurement=] given |intermediate memory measurement|.
  1. Queue a task that resolves |promise| with |memory measurement|.
</div>


Converting an intermediate memory measurement to the result
-----------------------------------------------------------
<div algorithm>
  To <dfn lt="creating a new memory measurement|create a new memory measurement">create a new memory measurement</dfn>
  given an [=intermediate memory measurement=]  |intermediate measurement|:
  1. Let |bytes| be 0.
  1. [=For each=] [=intermediate memory breakdown entry=] |intermediate entry| in |intermediate measurement|:
      1. Set |bytes| to |bytes| plus |intermediate entry|'s [=intermediate memory breakdown entry/bytes=].
  1. Let |breakdown| be a new [=list=].
  1. [=For each=] [=intermediate memory breakdown entry=] |intermediate entry| in |intermediate measurement|:
      1. Let |breakdown entry| be the result of [=creating a new memory breakdown entry=] given |intermediate entry|.
      1. [=list/Append=] |breakdown entry| to |breakdown|.
  1. Let |jitter| be an [=empty memory breakdown entry=].
  1. Let |index| be a random number between 0 and [=list/size=] of |breakdown|.
  1. [=list/Insert=] |jitter| into |breakdown| before |index|.
  1. Return a new {{MemoryMeasurement}} whose:
      - {{MemoryMeasurement/bytes}} is |bytes|,
      - {{MemoryMeasurement/breakdown}} is |breakdown|.
</div>

<div algorithm>
  To <dfn lt="creating a new memory breakdown entry|create a new memory breakdown entry">create a new memory breakdown entry</dfn>
  given an [=intermediate memory breakdown entry=]  |intermediate entry|:
  1. Let |attribution| a new [=list=].
  1. [=For each=] {{JavaScript realm}} |realm| in |intermediate entry|'s [=intermediate memory breakdown entry/realms=]:
      1. Let |attribution entry| be the result of [=creating a new memory attribution=] given |realm|.
      1. [=list/Append=] |attribution entry| to |attribution|.
  1. Return a new {{MemoryBreakdownEntry}} whose:
      - {{MemoryBreakdownEntry/bytes}} is |intermediate entry|'s [=intermediate memory breakdown entry/bytes=],
      - {{MemoryBreakdownEntry/attribution}} is |attribution|,
      - {{MemoryBreakdownEntry/userAgentSpecificTypes}} is |intermediate entry|'s [=intermediate memory breakdown entry/user agent specific types=].
</div>

<div algorithm>
  To <dfn lt="creating a new memory attribution|create a new memory attribution">create a new memory attribution</dfn>
  given a {{JavaScript realm}} |realm|:
  1. Let |memory attribution token| be |realm|'s [=settings object=]'s [=environment settings object/memory attribution token=].
  1. If |memory attribution token|'s [=memory attribution token/cross-origin aggregated flag=] is true, then
      1. Return a new {{MemoryAttribution}} whose:
          - {{MemoryAttribution/url}} is null,
          - {{MemoryAttribution/container}} is |memory attribution token|'s [=memory attribution token/container=],
          - {{MemoryAttribution/scope}} is "cross-origin-aggregated".
  1. Let |scope name| be the result of [=getting the global scope name=] given |realm|'s [=global object=].
  1. Return a new {{MemoryAttribution}} whose:
      - {{MemoryAttribution/url}} is |realm|'s [=settings object=]'s [=environment settings object/creation URL=],
      - {{MemoryAttribution/container}} is |memory attribution token|'s [=memory attribution token/container=],
      - {{MemoryAttribution/scope}} is |scope name|.
</div>

<div algorithm>
  An <dfn>empty memory breakdown entry</dfn> is constructed as follows:
  1. Return a new {{MemoryBreakdownEntry}} whose:
      - {{MemoryBreakdownEntry/bytes}} is 0,
      - {{MemoryBreakdownEntry/attribution}} is an empty [=list=],
      - {{MemoryBreakdownEntry/userAgentSpecificTypes}} is an empty [=list=].
</div>


Creating or obtaining a memory attribution token
------------------------------------------------

<div algorithm>
  To <dfn lt="obtain window memory attribution token|obtaining window memory attribution token">obtain window memory attribution token</dfn>
  given an [=/origin=] |origin|, an [=/origin=] |parent origin|, an [=/origin=] |top-level origin|,
  an {{HTMLElement}} |container element|, an [=memory attribution token=] |parent token|:
  1. If |container element| is null, then:
      1. [=Assert=]: |parent origin| is null.
      1. [=Assert=]: |parent token| is null.
      1. [=Assert=]: |origin| is equal to |parent origin|
      1. Return a new [=memory attribution token=] whose:
          - [=memory attribution token/container=] is null,
          - [=memory attribution token/cross-origin aggregated flag=] is false.
  1. Let |container| be the result of [=extracting container element attributes=] given |container element|.
  1. If |origin| is equal to |top-level origin|, then:
      1. Return a new [=memory attribution token=] whose:
          - [=memory attribution token/container=] is |container|,
          - [=memory attribution token/cross-origin aggregated flag=] is false.
  1. If |parent origin| is equal to |top-level origin|, then:
      1. Return a new [=memory attribution token=] whose:
          - [=memory attribution token/container=] is |container|,
          - [=memory attribution token/cross-origin aggregated flag=] is true.
  1. Return |parent token|.
</div>

<div algorithm>
  To <dfn lt="obtain worker memory attribution token|obtaining worker memory attribution token">obtain worker memory attribution token</dfn>
  given {{WorkerGlobalScope}} |worker global scope|, an [=environment settings object=] |outside settings|:
  1. If |worker global scope| is a {{DedicatedWorkerGlobalScope}}, then
     return |outside settings|'s [=environment settings object/memory attribution token=].
  1. Assert: |worker global scope| is a {{SharedWorkerGlobalScope}} or a {{ServiceWorkerGlobalScope}}.
  1. Return a new [=memory attribution token=] whose:
      - [=memory attribution token/container=] is null,
      - [=memory attribution token/cross-origin aggregated flag=] is false.
</div>

<div algorithm>
  To <dfn lt="extract container element attributes|extracting container element attributes">extract container element attributes</dfn>
  given an {{HTMLElement}} |container element|:
  1. Switch on |container element|'s {{Element/tagName}}:
      <dl class="switch">
        : "iframe"
        :: Return a new {{MemoryAttributionContainer}} whose:
            - {{MemoryAttributionContainer/data}} is null,
            - {{MemoryAttributionContainer/id}} is |container element|'s {{Element/id}},
            - {{MemoryAttributionContainer/name}} is |container element|'s {{HTMLIFrameElement/name}},
            - {{MemoryAttributionContainer/src}} is |container element|'s {{HTMLIFrameElement/src}},
            - {{MemoryAttributionContainer/tagName}} is "iframe".

        : "frame"
        :: Return a new {{MemoryAttributionContainer}} whose:
            - {{MemoryAttributionContainer/data}} is null,
            - {{MemoryAttributionContainer/id}} is |container element|'s {{Element/id}},
            - {{MemoryAttributionContainer/name}} is |container element|'s {{HTMLFrameElement/name}},
            - {{MemoryAttributionContainer/src}} is |container element|'s {{HTMLFrameElement/src}},
            - {{MemoryAttributionContainer/tagName}} is "frame".

        : "object"
        :: Return a new {{MemoryAttributionContainer}} whose:
            - {{MemoryAttributionContainer/data}} is |container element|'s {{HTMLObjectElement/data}},
            - {{MemoryAttributionContainer/id}} is |container element|'s {{Element/id}},
            - {{MemoryAttributionContainer/name}} is |container element|'s {{HTMLObjectElement/name}},
            - {{MemoryAttributionContainer/src}} is null,
            - {{MemoryAttributionContainer/tagName}} is "object".
      </dl>
</div>

<div algorithm>
  To <dfn lt="get the global scope name|getting the global scope name">get the global scope name</dfn>
  given a {{WindowOrWorkerGlobalScope}} |scope|:
  1. Switch on |scope|:
      <dl class="switch">
        : if |scope| is a {{Window}}
        :: Return "window".
        : if |scope| is a {{DedicatedWorkerGlobalScope}}
        :: Return "dedicated-worker".
        : if |scope| is a {{SharedWorkerGlobalScope}}
        :: Return "shared-worker".
        : if |scope| is a {{ServiceWorkerGlobalScope}}
        :: Return "service-worker".
      </dl>
</div>


Integration with the existing specification
===========================================

Extensions to the {{Performance}} interface {#extensions-to-performance}
----------------------------------------------------------------------------------

<pre class="idl">
[Exposed=Window]
partial interface Performance {
  Promise&lt;MemoryMeasurement&gt; measureMemory();
};
</pre>
<dl class="domintro">
:  <code>self . {{Performance/measureMemory}}</code>
:: A method that performs an asynchronous memory measurement.
</dl>

Extension to environment settings object
----------------------------------------
A new field is added to [=envinronment settings object=]:
: A <dfn for="environment settings object">memory attribution token<dfn>
:: An [=memory attribution token=] that is used for reporting memory usage of this environment.

Extensions to the existing algorithms
-------------------------------------

The [$set up a window environment settings object$] algorithm gets a new [=memory attribution token=]
|memory attribution token| argument and copies it into the [=environment settings object/memory attribution token=]
field of |settings object| after step 7 of the existing algorithm:
    > 8. Set |settings object|'s [=environment settings object/memory attribution token=] to |memory attribution token|.

The [$set up a worker environment settings object$] algorithm sets
the [=environment settings object/memory attribution token=] field of |settings object| after step 7:
    > 8. Set |settings object|'s [=environment settings object/memory attribution token=]
         to the result of [=obtaining worker memory attribution token=] given
         |worker global scope| and |outside settings|.

The [$create and initialize a Document object$] algorithm creates a memory attribution token and passes it to
[$set up a window environment settings object$]:
    > 5. If browsingContext is not a top-level browsing context, then:
    >    4. Let |token| be the result of [=obtaining window memory attribution token=] with
    >       |origin|, |topLevelOrigin|, |browsingContext|'s container,
    >       |parentEnvironment|'s origin, |parentEnvironment|'s [=environment settings object/memory attribution token=].
    > 6. Else, let |token| be the result of [=obtaining window memory attribution token=] with
    >    |origin|, |topLevelOrigin|, null, null, null.
    > 7. Set up a window environment settings object with realm execution |context|, |reservedEnvironment|,
    >    |topLevelCreationURL|, |topLevelOrigin|, and |token|.

The [$create a new browsing context$] algorithm creates a memory attribution token and passes it to
[$set up a window environment settings object$]:
    > 10. If |embedder| is null, then let |token| be the result of [=obtaining window memory attribution token=]
    >     with |origin|, |topLevelOrigin|, |embedder|, |embedder|'s [=relevant settings object=]'s origin,
    >     |embedder|'s [=relevant settings object=]'s [=envinronment settings object/memory attribution token=].
    > 11. Else, let |token| be the result of [=obtaining window memory attribution token=] with |origin|,
    >     |topLevelOrigin|, null, null, null.
    > 12. Let |settingsObject| be the result of setting up a window environment settings object with
    >     |realm execution context|, null, |topLevelCreationURL|, |topLevelOrigin|, and |token|.


Privacy and Security
====================
<div nonnormative>
</div>

